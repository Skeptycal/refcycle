import contextlib
import gc
import inspect

__all__ = ['ObjectGraph', 'cycles_created_by', 'snapshot', 'disable_gc']

from refcycle.object_graph import ObjectGraph


@contextlib.contextmanager
def disable_gc():
    """
    Context manager to temporarily disable garbage collection.

    """
    if gc.isenabled():
        gc.disable()
        try:
            yield
        finally:
            gc.enable()
    else:
        # Nothing to do.
        yield


@contextlib.contextmanager
def set_gc_flags(flags):
    old_flags = gc.get_debug()
    gc.set_debug(flags)
    try:
        yield
    finally:
        gc.set_debug(old_flags)


def cycles_created_by(callable):
    """
    Return graph of cyclic garbage created by the given callable.

    Return an ObjectGraph representing those objects generated by the given
    callable that can't be collected by Python's usual reference-count based
    garbage collection.

    This includes objects that will eventually be collected by the cyclic
    garbage collector, as well as genuinely unreachable objects that will
    never be collected.

    `callable` should be a callable that takes no arguments; its return
    value (if any) will be ignored.

    """
    with disable_gc(), set_gc_flags(gc.DEBUG_SAVEALL):
        gc.collect()
        callable()
        new_object_count = gc.collect()
        objects = gc.garbage[-new_object_count:] if new_object_count else []
        return ObjectGraph(objects)


def snapshot():
    """
    Return the graph of all currently live objects.

    Excludes the returned ObjectGraph and objects owned by it.

    """
    all_objects = gc.get_objects()
    this_frame = inspect.currentframe()
    graph = ObjectGraph(
        [
            obj for obj in all_objects
            if obj is not this_frame
            if obj is not all_objects
        ]
    )
    del this_frame, all_objects
    return graph
